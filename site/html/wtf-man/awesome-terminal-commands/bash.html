<!DOCTYPE html>
<head>
<title>Bash Shell Builtin Commands</title>
</head><style>
html {
    margin:    0 auto;
    max-width: 670px;
}
</style>
<a href="../../../html/wtf-man.html" target="_blank"> 
  <img src="../../../resources/kenandritchie.png" border="0" />
</a>
<h2>Bash Shell Builtin Commands</h2>
<blockquote><table>
<tr><td valign=top><strong>"$x"</strong>						</td><td style="width:15px"></td><td>ALWAYS PUT DOUBLE QUOTES AROUND VARIABLE!!!!!!!!!!!!!!! </td></tr>
<tr><td></td><td></td><td>	   All variables in bash are global !!!!!!!</td></tr>
<tr><td valign=top><strong>"$*"</strong>						</td><td style="width:15px"></td><td>Combines all the arguments into single word, separating them with first character of IFS variable. If IFS is not set, space is used. If IFS is null, no separator is used!!!!!!!!! No args provided will result in one empty string being passed on!!! </td></tr>
<tr><td valign=top><strong>"$@"</strong>						</td><td style="width:15px"></td><td>Use this instead!!!!! Will retain arguments as-is, so no args provided will result in no args being passed on. This is in most cases what you want to use for passing on arguments.</td></tr>
<tr><td></td><td></td><td>	Google: "$@" is right almost everytime, and $* is wrong almost everytime.</td></tr>
<tr><td valign=top><strong>"$#"</strong>						</td><td style="width:15px"></td><td>number of arguments</td></tr>
<tr><td valign=top><strong>"$1"</strong>						</td><td style="width:15px"></td><td>first argument</td></tr>
<tr><td valign=top><strong>"$0"</strong>						</td><td style="width:15px"></td><td>name of the script</td></tr>
<tr><td valign=top><strong>$'n'</strong>						</td><td style="width:15px"></td><td>string literal with escape seqences (there is a backslash before n)</td></tr>
<tr><td></td><td></td><td><strong>	If you want IFS to be a new line (useful with for loop) you need to: IFS=$'n'</strong> - the dollar forces substitution!!!!!</td></tr>
<tr><td></td><td></td><td>	Also if you want 'while read line; do...' to preserve leading spaces and tabs, you need to set IFS=""</td></tr>
<tr><td valign=top><strong>$?</strong>						</td><td style="width:15px"></td><td>exit code of last command (0 - sucess)</td></tr>
<tr><td valign=top><strong></strong>					</td><td></td></tr>
<tr><td valign=top><strong>test &ltexpr&gt</strong>						</td><td style="width:15px"></td><td>same as [ &ltexpression&gt ], returns zero exit status if true.</td></tr>
<tr><td></td><td></td><td><strong>	-n</strong> - is string non empty, </td></tr>
<tr><td></td><td></td><td><strong>	-z</strong> - is string empty, </td></tr>
<tr><td></td><td></td><td><strong>	-a</strong> - and, </td></tr>
<tr><td></td><td></td><td><strong>	-o</strong> - or,</td></tr>
<tr><td></td><td></td><td><strong>	=</strong> - strings are equal, </td></tr>
<tr><td></td><td></td><td><strong>	-nt</strong> - file newer than, </td></tr>
<tr><td></td><td></td><td><strong>	-ot</strong> - older then,</td></tr>
<tr><td></td><td></td><td><strong>	-d</strong> - directory exists, </td></tr>
<tr><td></td><td></td><td><strong>	-e</strong> - file exists, </td></tr>
<tr><td></td><td></td><td><strong>	-f</strong> - is a regular file,</td></tr>
<tr><td></td><td></td><td><strong>	-h</strong> - its a symbolic link, </td></tr>
<tr><td></td><td></td><td><strong>	-r</strong> - has read permission,</td></tr>
<tr><td></td><td></td><td><strong>	-w</strong> - has write permission, </td></tr>
<tr><td></td><td></td><td><strong>	-x</strong> - has execute permission</td></tr>
<tr><td valign=top><strong>[[ &ltexpr&gt ]]</strong>						</td><td style="width:15px"></td><td>same as [, but without word splitting and filename expansion. And with additional operators: &&, ||, &lt, &gt (lexicographic less, more), and also regular expression matching.</td></tr>
<tr><td valign=top><strong>=~</strong>						</td><td style="width:15px"></td><td>regex comparison operator: [[ "$HOST" =~ ^user.* ]]</td></tr>
<tr><td valign=top><strong>let &ltexpr&gt</strong>						</td><td style="width:15px"></td><td>executes expression: let a="$b"+2</td></tr>
<tr><td valign=top><strong></strong>					</td><td></td></tr>
<tr><td valign=top><strong>$(command)</strong>						</td><td style="width:15px"></td><td>same as `command`</td></tr>
<tr><td valign=top><strong>$RANDOM</strong>						</td><td style="width:15px"></td><td>0 - 32767</td></tr>
<tr><td valign=top><strong>input=`cat`</strong>						</td><td style="width:15px"></td><td>getting standard input</td></tr>
<tr><td valign=top><strong>-</strong>						</td><td style="width:15px"></td><td>in place of a file name means standard in or out</td></tr>
<tr><td valign=top><strong>set</strong>						</td><td style="width:15px"></td><td><strong> -o vi</strong>						 - set line editing to vi mode</td></tr>
<tr><td valign=top><strong>pushd .</strong>						</td><td style="width:15px"></td><td>put current dir on stack</td></tr>
<tr><td valign=top><strong>popd</strong>						</td><td style="width:15px"></td><td>pop dir from stack</td></tr>
<tr><td valign=top><strong>cd</strong>						</td><td style="width:15px"></td><td>- go to last dir</td></tr>
<tr><td valign=top><strong>source &ltscript&gt</strong>						</td><td style="width:15px"></td><td>run script: for example source /etc/profile (same as . &ltcommand&gt)</td></tr>
<tr><td valign=top><strong>#!/bin/bash</strong>						</td><td style="width:15px"></td><td>good practice to insert at begining of a bash script</td></tr>
<tr><td valign=top><strong>export 	</strong>					</td><td style="width:15px"></td><td><strong>PATH="$PATH:&ltdir&gt"</strong>					- add new directory to path variable</td></tr>
<tr><td valign=top><strong>read</strong>						</td><td style="width:15px"></td><td><strong> -p "Press [Enter] key to start backup..."</strong>						 - prompt for user input</td></tr>
<tr><td valign=top><strong>var=${1:-"&ltdefault-value&gt"}</strong>						</td><td style="width:15px"></td><td>setting variable with default value if $1 is empty</td></tr>
<tr><td valign=top><strong>getopts</strong>						</td><td style="width:15px"></td><td>parse parameters/arguments, builtin</td></tr>
<tr><td valign=top><strong>getopt</strong>						</td><td style="width:15px"></td><td>GNU version is even better then getopts, not a builtin</td></tr>
<tr><td valign=top><strong>while read line; do &ltcommands&gt; done &lt &ltfile&gt</strong>						</td><td style="width:15px"></td><td>read from file line by line</td></tr>
<tr><td></td><td></td><td><strong>	-r</strong> - do not treat backslashes as escape characters</td></tr>
<tr><td valign=top><strong></strong>					</td><td></td></tr>
</table>
<h3 align="center">History</h3>
<table>
<tr><td valign=top><strong></strong>					</td><td></td></tr>
<tr><td valign=top><strong>sudo !!</strong>						</td><td style="width:15px"></td><td>run the last command as root </td></tr>
<tr><td valign=top><strong>&ltspace&gtcommand</strong>						</td><td style="width:15px"></td><td>execute a command without saving it in the history</td></tr>
<tr><td valign=top><strong>!&ltterm&gt</strong>						</td><td style="width:15px"></td><td>last command that starts with term</td></tr>
<tr><td valign=top><strong></strong>					</td><td></td></tr>
</table>
<h3 align="center">Redirections</h3>
<table>
<tr><td valign=top><strong></strong>					</td><td></td></tr>
<tr><td valign=top><strong>&ltcommand&gt 2&gt /dev/null</strong>						</td><td style="width:15px"></td><td>redirect error output</td></tr>
<tr><td valign=top><strong>&ltcommand&gt &&gt /dev/null</strong>						</td><td style="width:15px"></td><td>redirect both standard and error output</td></tr>
<tr><td valign=top><strong>&ltcommand&gt &gt&2</strong>						</td><td style="width:15px"></td><td>write to stderr</td></tr>
<tr><td valign=top><strong>&ltcommand&gt 2&gt&1 | less</strong>						</td><td style="width:15px"></td><td>add stderr to stdout and print it with less (useful for gcc)</td></tr>
<tr><td valign=top><strong></strong>					</td><td></td></tr>
</table>
<h3 align="center">Arrays And Lines</h3>
<table>
<tr><td valign=top><strong></strong>					</td><td></td></tr>
<tr><td valign=top><strong>while read -r line; do</strong>							</td><td></td></tr>
<tr><td valign=top><strong>    echo "... $line ..."</strong>					</td><td></td></tr>
<tr><td valign=top><strong>done &lt&lt&lt "$list"</strong>						</td><td style="width:15px"></td><td>reading line by line from variable</td></tr>
<tr><td valign=top><strong>${a[1]}</strong>						</td><td style="width:15px"></td><td>value of the second element of the array</td></tr>
<tr><td valign=top><strong>for c in ${a[@]}</strong>						</td><td style="width:15px"></td><td>iterate over array</td></tr>
<tr><td valign=top><strong>${varname:offset:length}</strong>						</td><td style="width:15px"></td><td>get substring: s="aeiou"; ${s:3:1} -&gt o</td></tr>
<tr><td valign=top><strong>${#var}</strong>						</td><td style="width:15px"></td><td>length of a var </td></tr>
<tr><td valign=top><strong>${#name[subscript]}</strong>						</td><td style="width:15px"></td><td>length  of the element</td></tr>
<tr><td valign=top><strong>${#name[@]}</strong>						</td><td style="width:15px"></td><td>length  of the array</td></tr>
<tr><td valign=top><strong></strong>					</td><td></td></tr>
</table>
<h3 align="center">Aliases</h3>
<table>
<tr><td valign=top><strong></strong>					</td><td></td></tr>
<tr><td valign=top><strong>alias</strong>						</td><td style="width:15px"></td><td>print all aliases</td></tr>
<tr><td></td><td></td><td><strong>	&ltname&gt</strong> - print alias</td></tr>
<tr><td></td><td></td><td><strong>	&ltname&gt='cmd'</strong> - set alias</td></tr>
<tr><td valign=top><strong>command &ltcommand&gt</strong>						</td><td style="width:15px"></td><td>executes original command, bypassing any aliases or shell functions that may be defined for command</td></tr>
<tr><td valign=top><strong>&ltcommand&gt</strong>						</td><td style="width:15px"></td><td>temporarily disable alias (call original)</td></tr>
<tr><td valign=top><strong>type &ltcommand&gt</strong>						</td><td style="width:15px"></td><td>will tell you what is command aliased to</td></tr>
<tr><td valign=top><strong></strong>					</td><td></td></tr>
</table></blockquote>
