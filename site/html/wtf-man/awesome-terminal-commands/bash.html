<h1>BASH</h1>

<p>"$x" - ALWAYS PUT DOUBLE QUOTES AROUND VARIABLE!!!!!!!!!!!!!!! 
"$<em>" - combines all the arguments into single word, separating them with first character of IFS variable. If IFS is not set, space is used. If IFS is null, no separator is used!!!!!!!!! No args provided will result in one empty string being passed on!!! 
"$@" - Use this instead!!!!! Will retain arguments as-is, so no args provided will result in no args being passed on. This is in most cases what you want to use for passing on arguments.
Google: "$@" is right almost everytime, and $</em> is wrong almost everytime.
"$#" - number of arguments
"$1" - first argument
"$0" - name of the script
$'n' - string literal with escape seqences
If you want IFS to be a new line (useful with for loop) you need to: IFS=$'n' - the dollar forces substitution!!!!!
$? - exit code of last command (0 - ok)</p>

<p>test <expression> - same as [ <expression> ], -gt, -d,... Returns zero exit status if true.
    -n - is string non empty, -z - is string empty, -a - and, -o - or,
    = - strings are equal, -nt - file newer than, -ot - older then,
    -d - directory exists, -e - file exists, -f - is a regular file,
    -h - its a symbolic link, -r - has read permission,
    -w - has write permission, -x - has execute permission
[[ <expression> ]] - same as [, but without word splitting and filename expansion. And with additional operators: &amp;&amp;, ||, &lt;, > (lexicographic less, more), and also regular expression matching.
let <expression> - executes expression</p>

<p>$(command) - same as <code>command</code>
$RANDOM - 0 - 32767
input=<code>cat</code> - getting standard input
- in place of a file name means standard in or out
set -o vi - set line editing to vi mode
pushd . - put current dir on stack
popd - pop dir from stack
cd - - go to last dir
source <script> - run script: for example source /etc/profile (same as . <command>)</p>

<h1>!/bin/bash - good practice to insert at begining of a bash script</h1>

<p>export PATH="$PATH:<your-dir>" - add new directory to path variable
All variables in bash are global !!!!!!!
read -p "Press [Enter] key to start backup..." - prompt for user input
variable=${1:-"default value"} - setting variable with default value if $1 is empty
getopts - parse parameters/arguments
getopt - GNU version is even better then getopts, not a builtin
while read line; do <COMANDS>; done &lt; <FILENAME> - read from file line by line</p>

<p>HISTORY:</p>

<p>sudo !! - Run the last command as root 
<space>command - Execute a command without saving it in the history
!<term> - last command that starts with term</p>

<p>ARRAYS AND LINES:</p>

<p>while read -r line; do
    echo "... $line ..."
done &lt;&lt;&lt; "$list" - reading line by line from variable
${a[1]} - value of the second element of the array
for c in ${a[@]} - iterate over array
${varname:offset:length} - get substring: s="aeiou"; ${s:3:1} -> o
${#var} - length of a var 
${#name[subscript]} - length  of the element
${#name[@]} - length  of the array</p>

<p>REDIRECTIONS:</p>

<p><command> 2> /dev/null - redirect error output
<command> &amp;> /dev/null - redirect both standard and error output
<command> >&amp;2 - write to stderr
<command> 2>&amp;1 | less - add stderr to stdout and print it with less (useful for gcc)</p>

<p>ALIASES:</p>

<p>alias - print all aliases
    <name> - print alias
    <name>='cmd' - set alias
command <command> - executes original command, bypassing any aliases or shell functions that may be defined for command
<command> - temporarily disable alias (call original)
type <command> - will tell you what is command aliased to
bash -n <script> - check for errors
mkdir -p - make parents if needed</p>
