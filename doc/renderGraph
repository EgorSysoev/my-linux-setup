#!/bin/bash

USAGE=`basename "$0"`" [ASCII GRAPH FILE]"
DESCRIPTION="Reads a graph from ascii drawing and creates png file using image magic convert command."

if [[ "$#" -ne 1 || "$1" == "--help" ]]; then
	echo -e "Usage: $USAGE"; echo -e "$DESCRIPTION"; exit
fi

#########

DEBUG=true

# Size factor (how many pixels does one cell take up)
SIZEY=60
SIZEX=`echo "scale=1;$SIZEY*2/3" | bc | sed 's/\..*//'`
let FONT_SIZE=("$SIZEY"*3)/4
#FONT="DejaVu-Sans-Mono-Oblique"
FONT="DejaVu-Sans-Mono-Bold"

#######################
#### PROCESS LABEL ####
#######################

# Reads label until it reaches connector or space
# Draws rectangle and label on it.
processLabel() {
	restOfLine=${lines[$y]:$x}
	label=`echo "$restOfLine" | grep -o "^[^ -+()|\n]*"`
	length=${#label}
	let newX="$x"+"$length"
	let yPlus1="$y"+1
	# RECTANGLE:
	let RECTANGLE_OFFSET="$SIZEX"/8
	let rectangleX="$x"*"$SIZEX"+"$RECTANGLE_OFFSET"
	let rectangleY="$y"*"$SIZEY"+"$RECTANGLE_OFFSET"
	let rectangleX2="$newX"*"$SIZEX"-"$RECTANGLE_OFFSET"
	let rectangleY2="$yPlus1"*"$SIZEY"-"$RECTANGLE_OFFSET"
	instructionRectangle="rectangle $rectangleX,$rectangleY $rectangleX2,$rectangleY2\n"
	# TEXT:
	FONT_WIDTH_FACTOR="0.6107" # 0.6 prevec u desno, 0.65 prevec v levo, 0.625 mal v levo, 0.62 mal v levo, 0.615 levo,
    textWidthExpression="scale=1;$FONT_SIZE*$length*$FONT_WIDTH_FACTOR"
	textWidth=$(echo "$textWidthExpression" | bc | sed 's/\..*//')
	let rectangleWidth="$length"*"$SIZEX"-2*"$RECTANGLE_OFFSET"
	let textOffsetX=("$rectangleWidth"-"$textWidth")/2+"$RECTANGLE_OFFSET"
	let textX="$x"*"$SIZEX"+"$textOffsetX"
	let textOffsetY=("$SIZEY"-2*"$RECTANGLE_OFFSET"-"$FONT_SIZE")/2
	let textY="$yPlus1"*"$SIZEY"-"$RECTANGLE_OFFSET"-2*"$textOffsetY"
	instructionText="text $textX,$textY '$label'\n"



#	lableOffsetX=`echo "scale=1;($SIZEX*$length-2*$RECTANGLE_OFFSET-$FONT_SIZE*(0.6)*$length)/2" | bc | sed 's/\..*//'`
#	let textScaledX="$x"*"$SIZEX"+"$lableOffsetX"
#	let lableOffsetY=("$SIZEY"-2*"$RECTANGLE_OFFSET"-"$FONT_SIZE")/2
#	let textScaledY="$yPlus1"*"$SIZEY"-"$RECTANGLE_OFFSET"-2*"$lableOffsetY"
#	instructionText="text $textScaledX,$textScaledY '$label'\n"

	instructions="$instructions""$instructionRectangle""$instructionText"
	x="$newX"
}

######################
#### PROCESS NODE ####
######################

# Draws a circle and nodes label on it.
processNode() {
	let xPlus1="$x"+1
	let yPlus1="$y"+1
	label=${lines[$y]:$xPlus1:1}

	let circleX="$xPlus1"*"$SIZEX"+"$SIZEX"/2
	let circleY="$y"*"$SIZEY"+"$SIZEY"/2
	let circleY2="$y"*"$SIZEY"
	let labelX="$xPlus1"*"$SIZEX"
	let labelY="$yPlus1"*"$SIZEY"-"$SIZEY"/4

	instruction="m#circle $circleX,$circleY $circleX,$circleY2\ntext $labelX,$labelY '$label'"
	instructions="$instructions""$instruction""\n"

	let x="$x"+2
}

######################
#### PROCESS EDGE ####
######################

# Investigates where does edge lead and draws a line between the ends.
processEdge() {
	local char=${lines[$y]:$x:1}
	if [[ "$char" == '|' ]]; then
		findEdgesEndpoints 0 -1 0 1 "$char"
	elif [[ "$char" == '-' ]]; then
		findEdgesEndpoints -1 0 1 0 "$char"
	elif [[ "$char" == '/' ]]; then
		findEdgesEndpoints 1 -1 -1 1 "$char"
	elif [[ "$char" == '\' ]]; then
		findEdgesEndpoints -1 -1 1 1 "$char"
	fi

	instruction="line $endpoint1 $endpoint2"
	instructions="$instructions""$instruction""\n"
}

# Finds the two endpoints of the edge
# Arguments: 
# $1 - delta x of first direction, $2 - delta y of first direction,
# $3 - delta x of oposite direction, $4 - delta y of oposite direction
# $5 - the character reptesenting the edge
findEdgesEndpoints() {
	connectToX="$x"; connectToY="$y"
	findEdgesEndpoint "$1" "$2" "$5"
	let connectToX="$connectToX"*"$SIZEX"+"$SIZEX"/2
	let connectToY="$connectToY"*"$SIZEY"+"$SIZEY"/2
	endpoint1="$connectToX,$connectToY"
	connectToX="$x"; connectToY="$y"
	findEdgesEndpoint "$3" "$4" "$5"
	let connectToX="$connectToX"*"$SIZEX"+"$SIZEX"/2
	let connectToY="$connectToY"*"$SIZEY"+"$SIZEY"/2
	endpoint2="$connectToX,$connectToY"
}

# Finds the endpoint in the specified direction
# $1 - delta x of direction, $2 - delta y of direction,
# $3 - the character reptesenting the edge
findEdgesEndpoint() {
	let newX="$connectToX"+"$1"
	let newY="$connectToY"+"$2"
	local char=${lines[$newY]:$newX:1}
	if [[ -z "$char" || "$char" == ' ' ]]; then
		return
	# If this field has the same edge character, continue to next one
	elif [[ "$char" == "$3" ]]; then
		connectToX="$newX"
		connectToY="$newY"
		findEdgesEndpoint "$@"	
	elif [[ "$char" == '(' ]]; then
		let connectToX="newX"+1
		let connectToY="newY"
		return
	elif [[ "$char" == ')' ]]; then
		let connectToX="newX"-1
		let connectToY="newY"
		return
	else
		connectToX="$newX"
		connectToY="$newY"
		return
	fi
}

#### CALCULATE CANVAS SIZE ####

calculateCanvasSize() {
	# Calculate size of the canvas.
	let canvasSizeY=${#lines[@]}*"$SIZEY"
	canvasSizeX=0
	for (( y=0 ; y < ${#lines[@]} ; y++ )); do
		if [[ ${#lines["$y"]} -gt "canvasSizeX" ]]; then
			canvasSizeX=${#lines["$y"]}
		fi
	done
	let canvasSizeX="$canvasSizeX"*"$SIZEX"
}

##############
#### MAIN ####
##############

main() {

	# Copy lines into array
	SAVE_IFS="$IFS"
	IFS=$'\n'
	i=0
	for a in `cat "$1"`; do
		lines["$i"]="$a"
		let i="$i"+1
	done
	IFS="$SAVE_IFS"

	# Drawing instructions for the imagemagic
	instructions=""

	EDGE='-|/\'
	CONNECTORS='-|/\+()'
	CONNECTORS_AND_SPACE='-|/\+() '

	if [[ "$DEBUG" == "true" ]]; then
		echo "INPUT FILE:"
		cat "$1"
		echo -e "\nPARSING:"
	fi

	# Parse.
	for (( y=0 ; y < ${#lines[@]} ; y++ )); do
		if [[ "$DEBUG" == "true" ]]; then
			echo -e "\nLine no $y: \"${lines[$y]}\""
		fi
		for (( x=0 ; x < ${#lines[y]} ; x++ )); do
			# getChar "$x" "$y":
			char=${lines[$y]:$x:1}
			if [[ "$DEBUG" == "true" ]]; then
				echo -en "\n$x" "$y" \""$char"\"' '
			fi	
			if [[ '-|/\\+() ' != *"$char"* ]]; then
				if [[ "$DEBUG" == "true" ]]; then
					echo -n label 
				fi
				processLabel
			fi
			if [[ "$char" == '(' ]]; then
				if [[ "$DEBUG" == "true" ]]; then
					echo -n node 
				fi
				processNode 
			fi
			if [[ '-|/\' == *"$char"* ]]; then
				if [[ "$DEBUG" == "true" ]]; then
					echo -n edge
				fi
				processEdge
			fi
		done
		echo
	done

	# Sort instructions so that edges get drawn first, then circles
	# and rectangles and lastly the labels.
	orderedInstructions=`echo -e "$instructions" | sort -u | sed 's/^.*#//'`
	if [[ "$DEBUG" == "true" ]]; then
		echo -e "\nINSTRUCTIONS:\n$orderedInstructions"
	fi
	drawingInstructions=`echo -e "$orderedInstructions" | grep -v '^text '`
	textInstructions=`echo -e "$orderedInstructions" | grep '^text '`

	calculateCanvasSize

	# Create png.
	echo -e "push graphic-context\n" > tmp.mvg
	echo -e "viewbox 0 0 $canvasSizeX $canvasSizeY" >> tmp.mvg
	echo -e "font-size $FONT_SIZE" >> tmp.mvg
	echo -e "font '$FONT'" >> tmp.mvg
	echo -e "fill 'white'" >> tmp.mvg
	echo -e "stroke 'black'" >> tmp.mvg
	echo -e "$drawingInstructions\n" >> tmp.mvg
	echo -e "fill 'black'\n" >> tmp.mvg
	echo -e "$textInstructions\n" >> tmp.mvg
	echo -e "pop graphic-context" >> tmp.mvg
	convert tmp.mvg tmp.png
}

main "$@"
