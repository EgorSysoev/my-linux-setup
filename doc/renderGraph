#!/bin/bash

USAGE=`basename "$0"`" [ASCII GRAPH FILE]"
DESCRIPTION="Reads a graph from ascii drawing and creates png file using image magic convert command."

if [[ "$#" -ne 1 || "$1" == "--help" ]]; then
	echo -e "Usage: $USAGE"; echo -e "$DESCRIPTION"; exit
fi

#########

DEBUG=true

#######################
#### PROCESS LABEL ####
#######################

# Reads label until it reaches connector or space
# Draws rectangle and label on it.
processLabel() {
	restOfLine=${lines[$y]:$x}
	label=`echo "$restOfLine" | grep -o "^[^ -+()|\n]*"`
	length=${#label}
	let newX="$x"+"$length"
	let yPlus1="$y"+1

	let scaledX="$x"*"$SIZEX"
	let scaledY="$y"*"$SIZEY"
	let scaledX2="$newX"*"$SIZEX"
	let scaledY2="$yPlus1"*"$SIZEY"

	instruction="rectangle $scaledX,$scaledY $scaledX2,$scaledY2\ntext $scaledX,$scaledY2 '$label'"
	instructions="$instructions""$instruction""\n"

	x="$newX"
}

######################
#### PROCESS NODE ####
######################

# Draws a circle and nodes label on it.
processNode() {
	let xPlus1="$x"+1
	let yPlus1="$y"+1
	label=${lines[$y]:$xPlus1:1}

	let circleX="$xPlus1"*"$SIZEX"+"$SIZEX"/2
	let circleY="$y"*"$SIZEY"+"$SIZEY"/2
	let circleY2="$y"*"$SIZEY"
	let labelX="$xPlus1"*"$SIZEX"
	let labelY="$yPlus1"*"$SIZEY"-"$SIZEY"/4

	instruction="m#circle $circleX,$circleY $circleX,$circleY2\ntext $labelX,$labelY '$label'"
	instructions="$instructions""$instruction""\n"

	let x="$x"+2
}

######################
#### PROCESS EDGE ####
######################

# Investigates where does edge lead and draws a line between the ends.
processEdge() {
	local char=${lines[$y]:$x:1}
	if [[ "$char" == '|' ]]; then
		findEdgesEndpoints 0 -1 0 1 "$char"
	elif [[ "$char" == '-' ]]; then
		findEdgesEndpoints -1 0 1 0 "$char"
	elif [[ "$char" == '/' ]]; then
		findEdgesEndpoints 1 -1 -1 1 "$char"
	elif [[ "$char" == '\' ]]; then
		findEdgesEndpoints -1 -1 1 1 "$char"
	fi

	instruction="line $endpoint1 $endpoint2"
	instructions="$instructions""$instruction""\n"
}

# Finds the two endpoints of the edge
# Arguments: 
# $1 - delta x of first direction, $2 - delta y of first direction,
# $3 - delta x of oposite direction, $4 - delta y of oposite direction
# $5 - the character reptesenting the edge
findEdgesEndpoints() {
	connectToX="$x"; connectToY="$y"
	findEdgesEndpoint "$1" "$2" "$5"
	let connectToX="$connectToX"*"$SIZEX"+"$SIZEX"/2
	let connectToY="$connectToY"*"$SIZEY"+"$SIZEY"/2
	endpoint1="$connectToX,$connectToY"
	connectToX="$x"; connectToY="$y"
	findEdgesEndpoint "$3" "$4" "$5"
	let connectToX="$connectToX"*"$SIZEX"+"$SIZEX"/2
	let connectToY="$connectToY"*"$SIZEY"+"$SIZEY"/2
	endpoint2="$connectToX,$connectToY"
}

# Finds the endpoint in the specified direction
# $1 - delta x of direction, $2 - delta y of direction,
# $3 - the character reptesenting the edge
findEdgesEndpoint() {
	let newX="$connectToX"+"$1"
	let newY="$connectToY"+"$2"
	local char=${lines[$newY]:$newX:1}
	if [[ -z "$char" || "$char" == ' ' ]]; then
		return
	# If this field has the same edge character, continue to next one
	elif [[ "$char" == "$3" ]]; then
		connectToX="$newX"
		connectToY="$newY"
		findEdgesEndpoint "$@"	
	elif [[ "$char" == '(' ]]; then
		let connectToX="newX"+1
		let connectToY="newY"
		return
	elif [[ "$char" == ')' ]]; then
		let connectToX="newX"-1
		let connectToY="newY"
		return
	else
		connectToX="$newX"
		connectToY="$newY"
		return
	fi
}

##############
#### MAIN ####
##############

main() {
	# Size factor
	SIZEY=60
	SIZEX=`echo "scale=1;$SIZEY*2/3" | bc | sed 's/\..*//'`

	# Copy lines into array
	SAVE_IFS="$IFS"
	IFS=$'\n'
	i=0
	for a in `cat "$1"`; do
		lines["$i"]="$a"
		let i="$i"+1
	done
	IFS="$SAVE_IFS"

	# Drawing instructions for the imagemagic
	instructions=""

	EDGE='-|/\'
	CONNECTORS='-|/\+()'
	CONNECTORS_AND_SPACE='-|/\+() '

	if [[ "$DEBUG" == "true" ]]; then
		echo "INPUT FILE:"
		cat "$1"
		echo -e "\nPARSING:"
	fi

	# Parse.
	for (( y=0 ; y < ${#lines[@]} ; y++ )); do
		if [[ "$DEBUG" == "true" ]]; then
			echo -e "\nLine no $y: \"${lines[$y]}\""
		fi
		for (( x=0 ; x < ${#lines[y]} ; x++ )); do
			# getChar "$x" "$y":
			char=${lines[$y]:$x:1}
			if [[ "$DEBUG" == "true" ]]; then
				echo -en "\n$x" "$y" \""$char"\"' '
			fi	
			if [[ '-|/\\+() ' != *"$char"* ]]; then
				if [[ "$DEBUG" == "true" ]]; then
					echo -n label 
				fi
				processLabel
			fi
			if [[ "$char" == '(' ]]; then
				if [[ "$DEBUG" == "true" ]]; then
					echo -n node 
				fi
				processNode 
			fi
			if [[ '-|/\' == *"$char"* ]]; then
				if [[ "$DEBUG" == "true" ]]; then
					echo -n edge
				fi
				processEdge
			fi
		done
		echo
	done

	# Sort instructions so that edges get drawn first, then circles
	# and rectangles and lastly the labels.
	orderedInstructions=`echo -e "$instructions" | sort -u | sed 's/^.*#//'`
	if [[ "$DEBUG" == "true" ]]; then
		echo -e "\nINSTRUCTIONS:\n$orderedInstructions"
	fi
	drawingInstructions=`echo -e "$orderedInstructions" | grep -v '^text '`
	textInstructions=`echo -e "$orderedInstructions" | grep '^text '`

	# Calculate size of the canvas.
	let sizeY=${#lines[@]}*"$SIZEY"
	sizeX=0
	for (( y=0 ; y < ${#lines[@]} ; y++ )); do
		if [[ ${#lines["$y"]} -gt "sizeX" ]]; then
			sizeX=${#lines["$y"]}
		fi
	done
	let sizeX="$sizeX"*"$SIZEX"

	# Create png.
	let fontSize="$sizeY"/11
	echo -e "push graphic-context\n" > tmp.mvg
	echo -e "viewbox 0 0 $sizeX $sizeY\n" >> tmp.mvg
	echo -e "font-size $fontSize\n" >> tmp.mvg
	echo -e "fill 'white'\n" >> tmp.mvg
	echo -e "stroke 'black'\n" >> tmp.mvg
	echo -e "$drawingInstructions\n" >> tmp.mvg
	echo -e "fill 'black'\n" >> tmp.mvg
	echo -e "$textInstructions" >> tmp.mvg
	echo -e "pop graphic-context" >> tmp.mvg
	convert tmp.mvg tmp.png
}

main "$@"
